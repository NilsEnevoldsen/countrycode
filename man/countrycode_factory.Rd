% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/countrycode_factory.R
\name{countrycode_factory}
\alias{countrycode_factory}
\title{Create new conversion functions with alternative dictionaries
and/or defaults arguments.}
\usage{
countrycode_factory(
  origin = NULL,
  destination = NULL,
  warn = NULL,
  nomatch = NULL,
  custom_dict = NULL,
  custom_match = NULL
)
}
\arguments{
\item{origin}{Coding scheme of origin (string such as \code{"iso3c"}). See
\code{\link{codelist}} for a list of available codes.}

\item{destination}{Coding scheme of destination (string such as \code{"iso3c"}). See
\code{\link{codelist}} for a list of available codes.}

\item{warn}{Prints unique elements from sourcevar for which no match was found}

\item{nomatch}{When countrycode fails to find a match for the code of
origin, it fills-in the destination vector with \code{nomatch}. The default
behavior is to fill non-matching codes with \code{NA}. If \code{nomatch = NULL},
countrycode tries to use the origin vector to fill-in missing values in the
destination vector. \code{nomatch} must be either \code{NULL}, of length 1, or of the same
length as \code{sourcevar}.}

\item{custom_dict}{A data frame which supplies a new dictionary to
replace the built-in country code dictionary. Each column
contains a different code and must include no duplicates. The
data frame format should resemble \code{\link{codelist}}. Users
can pre-assign attributes to this custom dictionary to affect
behavior (see Examples section):
\itemize{
\item "origin.regex" attribute: a character vector with the names
of columns containing regular expressions.
\item "origin.valid" attribute: a character vector with the names
of columns that are accepted as valid origin codes.
}}

\item{custom_match}{A named vector which supplies custom origin and
destination matches that will supercede any matching default result. The name
of each element will be used as the origin code, and the value of each
element will be used as the destination code.}
}
\description{
This function can be used to set new default arguments for the
\code{countrycode} functions, or to create alternative functions using
your own conversion dictionary. The Examples section shows how to
use \code{countrycode_factory} to create a \code{statecode} function which
can be used to convert US states to abbreviations or long names.
}
\examples{
\dontrun{
 # Download the dictionary of US states from Github
 state_dict <- "https://raw.githubusercontent.com/vincentarelbundock/countrycode/main/data/custom_dictionaries/us_states.csv"
 state_dict <- read.csv(state_dict)

 # The "state.regex" column includes regular expressions, so we set an attribute.
 attr(state_dict, "origin_regex") <- "state.regex"

 # Set default values for the custom conversion function
 statecode <- countrycode_factory(
   origin = "state.regex",
   destination = "abbreviation",
   custom_dict = state_dict)

 # Convert
 x <- c("Alabama", "New Mexico")
 statecode(x, "state.regex", "abbreviation")

 x <- c("AL", "NM", "VT")
 statecode(x, "abbreviation", "state")
}
}
